# 代理


## 代理与AOP

OOP面向对象，允许开发者定义纵向的关系，但并适合用于定义横向的关系，导致大量的代码重复，而不利用各个模块重用。

AOP，一般称为面向切面，作为面向对象的一种补充，**用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块**，这个模块被称为“切面”（Aspect），减少系统中的重复代码，降低模块之间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。

AOP的实现的关键在于代理模式，AOP的主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。

1. AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ（切面）织入到Java字节码中，运行的时候就是增强之后的AOP对象。
2. Spring的AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成了一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调了原对象的方法。

**Spring AOP中的动态代理主要实现有两种方式，JDK动态代理和CGLIB动态代理**：

1. JDK动态代理只提供接口的代理，不支持类的代理。核心INvocationHandler接口和Proxy类，InvocationHandler通过invoke()方法反射来调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起；接着，Proxy利用InvocationHanler动态创建一个符合某一接口的实例，生成目标类的代理对象。
2. 如果代理类没有实现InvocationHandler接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以运行时动态的生成执行类的一个子类对象，并覆盖其中特定的方法并添加增强代码，从而实现AOP。CGLIB的通过继承的方式来指定类的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。
3. 静态代理和动态代理的区别在于生成AOP代理对象的实际不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP在无须特定的编译器处理。

>InvocationHandler的invoke(Object proxy, Method method, Object[] args)：proxy是最终生成的代理实例；method是被代理的目标实例的某个具体的方法；args是被代理的某个具体方法，在方法反射调用时使用。